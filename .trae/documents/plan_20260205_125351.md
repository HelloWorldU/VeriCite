Based on your documents, the **Open Core strategy** is excellent. It creates a funnel where the open-source CLI drives adoption and trust (GitHub Stars), while the Cloud/SaaS offering captures value from high-volume or enterprise users (Universities/Journals).

Here is the plan to build the **v0.1 MVP** skeleton:

### 1. Project Initialization

* Create a standard Python project structure:

  ```text
  VeriCite/
  ├── vericite/
  │   ├── core/         # Core logic (Slicer, OCR, Validator)
  │   ├── interfaces/   # Abstract base classes
  │   ├── utils/        # Helpers (PDF, Logger)
  │   └── cli.py        # Entry point
  ├── tests/
  └── pyproject.toml    # Dependency management
  ```

### 2. Dependency Management (`pyproject.toml`)

* **CLI**: `typer` (Standard for modern CLIs), `rich` (Terminal UI).

* **PDF**: `pymupdf` (fitz) for fast PDF processing.

* **OCR**: `paddlepaddle`, `paddleocr` (Local engine).

* **Network**: `requests` (API calls).

* **Matching**: `rapidfuzz` (Fuzzy string matching).

### 3. Core Component Implementation (MVP Scaffolding)

* **CLI (`cli.py`)**: Implement the `vericite scan <pdf> --engine <local|cloud>` command.

* **Smart Slicer (`slicer.py`)**: Implement basic logic to locate "References" pages using keyword matching.

* **OCR Engine (`ocr/`)**:

  * Define an abstract base class `OCREngine`.

  * Scaffold `LocalEngine` (PaddleOCR wrapper).

  * Scaffold `CloudEngine` (DeepSeek/GLM API wrapper stub).

* **Validator (`validator.py`)**: Scaffold the Crossref API client for citation verification.

### 4. Verification

* Create a dummy "Hello World" run to ensure the CLI and imports work correctly.

Shall we proceed with this structure?
